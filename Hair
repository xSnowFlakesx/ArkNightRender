Shader "Custom/UE5AnisotropicGGXhair"
{
    Properties
    {
        _BaseColor("Base Color", Color) = (1,1,1,1)
        _BaseMap("Albedo", 2D) = "white" {}
        _NormalMap("Normal Map", 2D) = "bump" {}
        _LowNormalMap("Low Normal Map", 2D) = "bump" {}
        _BumpScale("Bump Scale", Range(-5,5)) = 1
        _LowBumpScale("Low Bump Scale", Range(-5,5)) = 1
        _Roughness("Roughness", 2D) = "white"{}
        _MetallicMap("Metallic (R)", 2D) = "white" {}
        _Anisotropy("Anisotropy", Range(-10,10)) = 0
        _AnisoDirectionMap("Anisotropy Direction Map", 2D) = "white" {}
        _AnisoDirectionMap1("Anisotropy Direction Map1", 2D) = "white" {}

        _RampTex("Ramp Texture", 2D) = "white" {}
        _RampTex1("Ramp Texture1", 2D) = "white" {}
        _HairLineColor("Hair Line Color", Color) = (1,1,1,1)

        _HairDownMask("Hair Down Mask", 2D) = "white" {}
        _HairDownColor("Hair Down Color", Color) = (1,1,1,1)

        _AnisoSharpness("Sharpness", Range(1,100)) = 60
        _StripeDensity("Stripe Density", Range(1,200)) = 100
        _FlowSpeed("Flow Speed", Range(0,5)) = 1.2
        
        _Specular("Specular", Range(0,5)) = 0.5
        _SpecularColor("Specular Color", Color) = (1,1,1,1)
        _SpecularIntensity("Specular Intensity", Range(0,50)) = 0.5
        _SpecularTint("Specular Tint", Range(0,1)) = 0

        // 各向异性参数
        _AnisoSpecularColor("Specular Color", Color) = (1,1,1,1)
        _AnisoPrimaryShift("Primary Shift", Range(-1,1)) = 0.2
        _AnisoSecondaryShift("Secondary Shift", Range(-1,1)) = -0.1
        _AnisoGloss("Gloss", Range(1,512)) = 64

        _SideFalloff("Side Falloff", Range(1, 5)) = 2.0
        _HairLineMap("Hair Line Map", 2D) = "white" {}
        //_ToonSpecularSize("Toon Specular Size", Range(0,20)) = 1
        //_ToonSpecularSmooth("Toon Specular Smooth", Range(0,10)) = 0.5
        _AnisoRotation("Anisotropy Rotation", Range(0,1)) = 0 // 新增旋转控制
        _EnvironmentCube("Environment Cube", Cube) = "white" {}
        _SSRIntensity("SSR Intensity", Range(0,100))= 1
       _AlphaClip("Alpha Clip", Range(0,1)) = 0.333
       _AlphaTex("Alpha Texture", 2D) = "white" {}

       _OutLineWidth("Outline Width", Range(0,1)) = 0.01
        _MaxOutlineZoffset("Max Outline Zoffset", Range(0,1)) = 0.01
        _OutlineColor("Outline Color", Color) = (0,0,0,1)

    


       _HeadCenter("Head Center", Vector) = (0,0,0)
        [HideInInspector]_HeadForward("Head Forward", Vector) = (0,0,0)
        [HideInInspector]_HeadRight("Head Right", Vector) = (0,0,0)
        _HeadSphereRange("Head Sphere Range", Range(0, 1)) = 0


        [Header(Draw Overlay)]
        [Toggle(_DRAW_OVERLAY_ON)] _DrawOverlayOn("Draw Overlay (Default NO)", Float) = 0.0

        
    }

    SubShader
    {
        Tags {
        "Queue" = "Geometry+100"  // 确保先于B渲染
        "RenderPipeline"="UniversalPipeline"
    }
        
        Pass
        {
            Name "ForwardLit"
            //Tags { "LightMode"="UniversalForward" }
            Tags { "LightMode" = "UniversalForward"
                "RenderType" = "Opaque"
                "Queue" = "Geometry + 100" // 确保在标准透明物体之后渲染
                "RenderPipeline" = "UniversalPipeline"
                "IgnoreProjector" = "True"}

                Stencil{
                    Ref 1
                    Comp GEqual
                    Pass Keep
                }

                Cull Back

            Blend SrcAlpha OneMinusSrcAlpha
            //BlendOp Add, Add
            //AlphaToMask On
            Offset 0, -1
            ZWrite On
            ZTest LEqual

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_fragment _ _SCREEN_SPACE_REFLECTION
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING
            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION

            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
            #pragma multi_compile _ _ADDITIONAL_LIGHTS
            #pragma multi_compile_fragment _ _SSR_ENABLED

            #pragma shader_feature_local _SCREEN_SPACE_RIM
            #pragma shader_feature_local _SCREEN_SPACE_SHADOW
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
             #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"



            struct Attributes
            {
                float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
                float4 tangentOS : TANGENT;
                float2 uv : TEXCOORD0;
            };

            struct Varyings
            {
                float2 uv : TEXCOORD0;
                float3 positionWS : TEXCOORD1;
                float3 normalWS : TEXCOORD2;
                float3 tangentWS : TEXCOORD3;
                float3 bitangentWS : TEXCOORD4;
                float3 viewDirWS : TEXCOORD5;
                float4 positionCS : SV_POSITION;
            };

            TEXTURE2D(_BaseMap);
            TEXTURE2D(_NormalMap);
            SAMPLER(sampler_NormalMap);
            float _BumpScale;
            SAMPLER(sampler_BaseMap);

            TEXTURE2D(_LowNormalMap);
            SAMPLER(sampler_LowNormalMap);
            float _LowBumpScale;
            
            CBUFFER_START(UnityPerMaterial)
            float4 _BaseMap_ST;
            half4 _BaseColor;
            float4 _SpecularColor;
            TEXTURE2D(_Roughness);
            sampler2D _AnisoDirectionMap;
            sampler2D _AnisoDirectionMap1;
            sampler2D _RampTex;
            sampler2D _RampTex1;
            sampler2D _HairLineMap;
            sampler2D _AlphaTex;
            sampler2D _HairDownMask;
            float4 _HairDownColor;
            TEXTURE2D(_MetallicMap);
            //TEXTURE2D(_MetallicMap);
SAMPLER(sampler_MetallicMap);
            float _Anisotropy;
            float _Specular;
            float _SpecularTint;
            //float _ToonSpecularSize;
            //float _ToonSpecularSmooth;
            float _SideFalloff;
            
            float _AnisoRotation;
            float _SSRIntensity;
            float _AlphaClip;
            float _SpecularIntensity;

            float _AnisoSharpness;
            float _StripeDensity;
            float _FlowSpeed;
            float4 _HairLineColor;

            float4 _AnisoSpecularColor;
            float _AnisoPrimaryShift;
            float _AnisoSecondaryShift;
            float _AnisoGloss;
            


            float3 _HeadCenter;
            float3 _HeadForward;
            float3 _HeadRight;
            float _HeadSphereRange;

            
        TEXTURE2D(_HairShiftMap);

            TEXTURECUBE(_EnvironmentCube);
            SAMPLER(sampler_EnvironmentCube);
            CBUFFER_END

            // UE5改进的各向异性分布函数
            float D_GGXAnisoUE5(float at, float ab, float ToH, float BoH, float NoH)
            {
                float ToH2 = ToH * ToH;
                float BoH2 = BoH * BoH;
                float NoH2 = NoH * NoH;
                float denominator = ToH2/(at*at) + BoH2/(ab*ab) + NoH2;
                denominator = PI * at * ab * (denominator * denominator);
                return 1.0 / denominator;
            }

            // UE5改进的几何项
            float V_SmithGGXCorrelatedAnisoUE5(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL)
            {
                float lambdaV = NoL * sqrt(NoV * (NoV - NoV * at) + at);
                float lambdaL = NoV * sqrt(NoL * (NoL - NoL * ab) + ab);
                return 0.5 / (lambdaV + lambdaL);
            }

float3 GlossyEnvironmentReflection(float3 reflectDir, float roughness, float occlusion)
{
    float3 envColor = SAMPLE_TEXTURECUBE(_EnvironmentCube, sampler_LinearClamp, reflectDir).rgb;
    return envColor * occlusion;
}
           // 修改旋转函数
// float2 RotateAnisotropy(float2 dir, float rotation)
// {
//     float angle = rotation * 2.0 * PI;
//     float sinRot, cosRot;
//     sincos(angle, sinRot, cosRot);
//     return float2(
//         dir.x * cosRot - dir.y * sinRot,
//         dir.x * sinRot + dir.y * cosRot
//         dir.x * sinRot + dir.y * cosRot + verticalOffset // 新增垂直偏移
//     );
// }

float2 RotateAnisotropy(float2 dir, float rotation, float verticalOffset) {
    float angle = rotation * 2.0 * PI;
    float sinRot, cosRot;
    sincos(angle, sinRot, cosRot);
    return float2(
        dir.x * cosRot - dir.y * sinRot,
        dir.x * sinRot + dir.y * cosRot + verticalOffset // 新增垂直偏移
    );
}


        float2 GetAnisotropyDirection(float2 uv, float rotation)
{
    // 采样方向贴图（RG通道表示XY方向）
    float2 baseDir = tex2D(_AnisoDirectionMap, uv).rg * 2 - 1;
    
    // 应用旋转矩阵（仅水平旋转）
    float2x2 rotMat = float2x2(
        cos(rotation), -sin(rotation),
        sin(rotation), cos(rotation)
    );
    return mul(rotMat, baseDir);
}


float3 CalculateSSR(float3 reflection, float3 positionWS, float roughness)
{
    #if defined(_SSR_ENABLED)
    // 修正1：使用正确的屏幕UV计算
    float2 screenUV = (input.screenPos.xy / input.screenPos.w);
    #if UNITY_UV_STARTS_AT_TOP
    screenUV.y = 1.0 - screenUV.y;
    #endif
    
    // 修正2：使用URP内置深度采样方法
    float rawDepth = SampleSceneDepth(screenUV);
    float3 rayStart = GetCameraPositionWS();
    float3 rayDir = normalize(reflection);
    
    // 修正3：调整步进参数
    const int steps = 32; // 增加步数
    const float stepSize = 0.2; // 增大步长
    const float thickness = 0.1; // 增加厚度容差
    
    for(int i=1; i<=steps; i++)
    {
        float3 rayEnd = positionWS + rayDir * i * stepSize;
        float4 projEnd = TransformWorldToHClip(rayEnd);
        float2 uvEnd = projEnd.xy / projEnd.w * 0.5 + 0.5;
        
        // 处理平台差异
        #if UNITY_UV_STARTS_AT_TOP
        uvEnd.y = 1.0 - uvEnd.y;
        #endif
        
        // 跳过屏幕外坐标
        if(uvEnd.x < 0 || uvEnd.x > 1 || uvEnd.y < 0 || uvEnd.y > 1) 
            continue;
        
        float sceneDepth = SampleSceneDepth(uvEnd);
        float3 scenePos = ComputeWorldSpacePosition(uvEnd, sceneDepth, UNITY_MATRIX_I_VP);
        
        // 使用距离+法线双重检测
        float surfaceDiff = distance(rayEnd, scenePos);
        float3 sceneNormal = SampleSceneNormals(uvEnd);
        float normalCheck = saturate(dot(sceneNormal, -rayDir));
        
        if(surfaceDiff < stepSize * thickness && normalCheck > 0.3)
        {
            // 使用Mipmap优化采样
            return SAMPLE_TEXTURE2D_LOD(_CameraOpaqueTexture, sampler_CameraOpaqueTexture, uvEnd, roughness * 8).rgb;
        }
    }
    #endif
    return 0;
}

            Varyings vert(Attributes input)
            {
                Varyings output;
                VertexPositionInputs positionInputs = GetVertexPositionInputs(input.positionOS.xyz);
                output.positionCS = TransformObjectToHClip(input.positionOS);
                output.normalWS = TransformObjectToWorldNormal(input.normalOS);
                output.tangentWS = TransformObjectToWorldDir(input.tangentOS.xyz);
                // 计算副切线（注意手性控制）
                float sign = input.tangentOS.w * unity_WorldTransformParams.w; // 处理镜像缩放
                output.bitangentWS = cross(output.normalWS, output.tangentWS) * sign;

                //output.positionCS = positionInputs.positionCS;
                output.positionWS = TransformObjectToWorld(input.positionOS);

                VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);
                //output.normalWS = normalInput.normalWS;
                //output.tangentWS = float4(normalInput.tangentWS, input.tangentOS.w);
                //output.bitangentWS = normalInput.bitangentWS;

                output.viewDirWS = GetWorldSpaceViewDir(output.positionWS);;

                output.uv = TRANSFORM_TEX(input.uv, _BaseMap);
                return output;
            }

            half4 frag(Varyings input) : SV_Target
            {
                // 采样贴图
                half4 albedo = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv) * _BaseColor;
                //float3 normalTS = UnpackNormal(SAMPLE_TEXTURE2D(_NormalMap, sampler_BaseMap, input.uv));


                half4 packedNormal = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, input.uv);
                
               

 
                // 解包法线（从[0,1]映射到[-1,1]）
                half3 pixelNormalTS = UnpackNormalScale(packedNormal, _BumpScale);
                
                // 构建TBN矩阵
                float3x3 TBN = float3x3(
                    input.tangentWS.xyz,
                    input.bitangentWS,
                    input.normalWS
                );
                
                // 将法线转换到世界空间
                float3 pixelNormalWS = normalize(mul(pixelNormalTS, TBN));

                float roughness = SAMPLE_TEXTURE2D(_Roughness, sampler_BaseMap, input.uv).a;
                float metallic = SAMPLE_TEXTURE2D(_MetallicMap, sampler_BaseMap, input.uv).r;
                float hairSpecMask = SAMPLE_TEXTURE2D(_MetallicMap, sampler_BaseMap, input.uv).g;

                float ao = SAMPLE_TEXTURE2D(_MetallicMap, sampler_BaseMap, input.uv).b;
                //float3 F0 = lerp(0.04, albedo, metallic);
                // 原代码
                //float3 F0 = lerp(0.08 * _Specular, albedo, metallic);
                // 应改为标准PBR处理：
                const float DIELECTRIC_F0 = 0.04;
                float3 baseF0 = lerp(DIELECTRIC_F0, albedo, metallic);
                float3 F0 = baseF0 * _Specular * (1.0 - _SpecularTint) + 
                        albedo * _SpecularTint;
                
                // 构造正交化TBN矩阵
                //float3 N = normalize(input.normalWS);
                float3 N = pixelNormalWS;

                // HairSpecularNormal

                float4 packedSpecularNormal = SAMPLE_TEXTURE2D(_LowNormalMap, sampler_LowNormalMap, input.uv);

                float3 SpecularNormalTS = 0;
                
                SpecularNormalTS.xy = (packedSpecularNormal.ba * 2 - 1) * _LowBumpScale;
                SpecularNormalTS.z = sqrt(1 - saturate(dot(SpecularNormalTS.xy, SpecularNormalTS.xy)));

                float3 SpecularNormalWS = normalize(mul(SpecularNormalTS, TBN));

                float3 SpecularTangentWS = normalize(cross(SpecularNormalWS, float3(0, 1, 0)));
                float3 SpecularBitangentWS = normalize(cross(SpecularTangentWS, SpecularNormalWS));
                


                // float2 low_freq_xy = SAMPLE_TEXTURE2D(_LowNormalMap,sampler_LowNormalMap, input.uv).ba * 2.0 - 1.0;
                // float3 N_tangent_low = normalize(float3(low_freq_xy, sqrt(1.0 - dot(low_freq_xy, low_freq_xy))));
                // float3 N_world_low = normalize(TBN * N_tangent_low); // TBN为切线到世界矩阵
                // // 生成伪切线和伪副切线
                // float3 up = float3(0.0, 1.0, 0.0);
                // float3 T_pseudo = normalize(cross(N_world_low, up));
                // float3 B_pseudo = normalize(cross(T_pseudo, N_world_low));

                // // Kajiya-Kay高光计算
                // float3 anisotropicDir2 = B_pseudo;
                // float theta = acos(dot(L, anisotropicDir2));
                // float specularN1 = pow(sin(theta), _AnisoGloss);

                // // 高频法线漫反射
                // float2 high_freq_xy = texture(normalMap, uv).rg * 2.0 - 1.0;
                // float3 N_tangent_high = normalize(vec3(high_freq_xy, sqrt(1.0 - dot(high_freq_xy, high_freq_xy))));
                // float3 N_world_high = normalize(TBN * N_tangent_high);
                // float diffuse = max(dot(lightDir, N_world_high), 0.0);
                

                

                N = normalize(N);

                
                        bool useSphere = _HeadSphereRange > 0;

                        float3 shpereNormalWS = input.positionWS - _HeadCenter;
                        float len = length(shpereNormalWS);
                        shpereNormalWS = normalize(shpereNormalWS);
                //float sphereUsage = 1.0 - saturate((len - _HeadSphereRange) * 20);
                        float3 shapeNormalWS = lerp(N, shpereNormalWS, 0.3);
                        N = shapeNormalWS;
                        

                        // float attenuation = saturate(baseAttenuation * 1.5 + 0.5);
                        // float shapeNoL = dot(lightDirWS, shapeNormalWS);
                        // float shapeAttenuation = sqrt(saturate(shapeNoL * 0.5 + 0.5));

                        shapeNormalWS = useSphere ? shapeNormalWS : pixelNormalWS;
                        //shapeAttenuation = useSphere ? shapeAttenuation : attenuation;

                float3 T = normalize(input.tangentWS);
               // float3 B = // 使用URP内置计算的bitangentWS
                float3 B = normalize(input.bitangentWS); 
                T = normalize(T - N * dot(T, N));
                B = normalize(cross(N, T));
                T = cross(B, N);
                //float3x3 TBN = float3x3(T, B, N);


                // 各向异性方向旋转（新增）
                float2 anisoDir = GetAnisotropyDirection(input.uv, _AnisoRotation * 2 * PI);
                T = normalize(anisoDir.x * input.tangentWS + anisoDir.y * input.bitangentWS);
                B = normalize(cross(N, T));
                float3 B1 = normalize(cross(N, T));
                float _VerticalOffset1 = -0.6;
                //B = normalize(B + N * _VerticalOffset1); 

                //float3x3 TBN = float3x3(T, B, N);

                float hairLine = tex2D(_HairLineMap,input.uv*float2(2,1));
                float3 hairLineColor = hairLine * _HairLineColor;
                float hairLine2 = tex2D(_HairLineMap,input.uv*float2(1,1));


                // 准备光照参数
                float3 V = GetWorldSpaceNormalizeViewDir(input.positionWS);
                float3 L = normalize(_MainLightPosition.xyz);
                float3 H = normalize(L + V);
                
                float NoV = saturate(dot(N, V));
                float NoL = saturate(dot(N, L));
                NoL = smoothstep(0.1, 0.9, NoL);
                float NoH = saturate(dot(N, H));
                float ToH = dot(T, H);
                float BoH = dot(B, H);
                float ToV = dot(T, V);
                float BoV = dot(B, V);
                float ToL = dot(T, L);
                float BoL = dot(B, L);

                float HairToH = dot(SpecularBitangentWS, H);
                float HairSinTH = sqrt(1 - HairToH * HairToH);
                float HairSpecular = pow(HairSinTH, _AnisoGloss);
                 // 双层高光偏移
                float3 shiftedT = SpecularBitangentWS + input.normalWS * _AnisoPrimaryShift;
                shiftedT = normalize(shiftedT);
                float TdotHShifted = dot(shiftedT, H);
                float sinTHShifted = sqrt(1 - TdotHShifted * TdotHShifted);
                float primarySpec = pow(sinTHShifted, _AnisoGloss);

                // 次高光（可选项）
                float3 shiftedT2 = SpecularBitangentWS + input.normalWS * _AnisoSecondaryShift;
                shiftedT2 = normalize(shiftedT2);
                float TdotHShifted2 = dot(shiftedT2, H);
                float sinTHShifted2 = sqrt(1 - TdotHShifted2 * TdotHShifted2);
                float secondarySpec = pow(sinTHShifted2, _AnisoGloss * 2); // 更锐利

                // 合并高光
                float finalHairSpec = (primarySpec + secondarySpec * 0.5);

                float3 finalHairSpecColor = finalHairSpec * 1;

                

                

                // UE5各向异性参数计算
                 roughness = max(roughness, 0.001);
                float anisotropy = clamp(_Anisotropy, -0.99, 0.99);
                float at = max(roughness * (1.0 + anisotropy), 0.001);
                float ab = max(roughness * (1.0 - anisotropy), 0.001);

                float HairBoH = dot(SpecularBitangentWS, H);
                float HairNoH = dot(SpecularNormalWS,H);
                float HairToV = dot(SpecularBitangentWS, V);
                float HairBoL = dot(SpecularBitangentWS, L);
                float HairNoV = dot(SpecularNormalWS, V);
                float HairNoL = dot(SpecularNormalWS, L);
                float HairBoV = dot(SpecularBitangentWS, V);\
                float HairToL = dot(SpecularBitangentWS, L);

                // 计算D项
                float D = D_GGXAnisoUE5(at, ab, ToH, BoH, NoH);
                
                // 计算G项
                float G = V_SmithGGXCorrelatedAnisoUE5(at, ab, ToV, BoV, ToL, BoL, NoV, NoL);

                // UE5改进的菲涅尔计算
                //float3 F0 = lerp(0.08 * _Specular.xxx, albedo.rgb, _SpecularTint);
                float3 F = F0 + (1.0 - F0) * pow(1.0 - saturate(dot(H, V)), 5.0);

                // 能量守恒的BRDF计算
               float AnisoDirection = tex2D(_AnisoDirectionMap, input.uv*float2(10,1)).xy;
               float AnisoDirection1 = tex2D(_AnisoDirectionMap1, input.uv*float2(50,1)).xy;
               
                float3 specular = (D * G * F) * NoL;

                // ======== 新增高光整形技巧 ========
                // 1. 方向约束强化
                //float directionMask = saturate(dot(normalize(T), H) * _AnisoSharpness);
                
                //float directionMask2 = 1-saturate(dot(normalize(SpecularBitangentWS), H) * _AnisoSharpness - 5);
                //directionMask *= directionMask2;
                //directionMask = smoothstep(0.0, 0.8, directionMask);

                // 2. UV条纹生成（带流动效果）
                // float2 flowUV = input.uv + float2(0, _Time.y * _FlowSpeed * 0.1);
                // float stripeMask = saturate(sin(flowUV.y * _StripeDensity * PI) * 3.0);
                // stripeMask = smoothstep(0.1,1, stripeMask);

                // 3. 组合遮罩
                //specular *= directionMask;
                // 4. 边缘约束
                // float edgeMask = 1.0 - saturate(abs(dot(N, V)) * 3.0);
                // //specular *= (1.0 - edgeMask * 0.3);

                // // 4. 抗锯齿处理
                // float specularAA = smoothstep(0.4, 0.6, specular * (1.0 + fwidth(specular)*2.0));

                // // 基于视角的高光衰减
                // float sideAttenuation = saturate(dot(N, V)); // 计算视角方向与法线的夹角
                // //sideAttenuation = pow(sideAttenuation, 2.0); // 增强衰减效果
                // sideAttenuation = pow(sideAttenuation, _SideFalloff);

                // // 基于切线方向的高光限制
                // // float tangentAttenuation = saturate(dot(T, L)); // 计算切线方向与光线方向的夹角
                // // tangentAttenuation = tangentAttenuation; // 平滑衰减

                // // 结合两种方法
                // float combinedAttenuation = sideAttenuation;
                //specular *= combinedAttenuation; // 应用到高光

                // 保持原有后续处理
                //specular = lerp(specular, specularAA, 0.5);


                //specular = smoothstep(0, 1, specular);

                

                float2 rampUV = float2(primarySpec, 0.5);
                float3 RampColor =  tex2D(_RampTex, rampUV);

                float2 rampUV2 = float2(secondarySpec, 0.5);
                float3 RampColor2 =  tex2D(_RampTex1, rampUV2);

                RampColor = lerp(RampColor, RampColor2, 0.5);

                finalHairSpecColor *= AnisoDirection1;
                finalHairSpecColor *= (1-hairLine2);

                finalHairSpecColor *= _SpecularIntensity;

                finalHairSpec *= _SpecularColor.rgb;
                
                finalHairSpecColor *= RampColor;


                specular *= AnisoDirection1;
                specular *= (1-hairLine2);

                specular *= _SpecularIntensity;

                //specular *= _SpecularColor.rgb;
                
                specular *= RampColor;
                //specular *= albedo.rgb;
                

            
                // 添加环境光照
                float3 ambient = SampleSH(N) * albedo.rgb * ao;

                // 屏幕空间反射
                float3 reflection = reflect(-V, N);
                float3 ssr = CalculateSSR(reflection, input.positionWS, roughness) * _SSRIntensity;

                // 添加立方体贴图采样
                // float3 envReflection = GlossyEnvironmentReflection(
                //     reflect(-V, N),
                //     roughness,
                //     0.5
                // );
                // envReflection *= metallic;
                // 应使用预过滤的mipmap：
                float3 reflectDir = reflect(-normalize(input.viewDirWS), normalize(N));
                float mip = roughness * (1.7 - 0.7 * roughness) * 6.0;
                float3 envColor = SAMPLE_TEXTURECUBE_LOD(
                    _EnvironmentCube, 
                    sampler_LinearClamp, 
                    reflectDir, 
                    mip
                ).rgb;

                //specular *= envColor;
                envColor *= metallic;

                // 添加能量补偿项
                float3 kd = (1.0 - F) * (1.0 - metallic);
                float3 diffuse = albedo * kd / PI;

                float HairDownMask = tex2D(_AlphaTex, input.uv).r;

                HairDownMask = 1 - HairDownMask;

                float HairDownMask2 = tex2D(_HairDownMask, input.uv);

                HairDownMask2 = 1 - HairDownMask2;

                HairDownMask *=  HairDownMask2;

                HairDownMask = smoothstep(0.7,1, HairDownMask);
                





                //float HairDownMask = 
                



                //float HairDownMaskA = 
                float alpha = 1 - HairDownMask * _BaseColor.a;

                alpha = max(alpha, _AlphaClip);

                float3 HairDownColor = _HairDownColor.rgb * HairDownMask;
                

                // 添加多重散射近似
                //float3 multiBounce = 1.0 + F0 * (1.0 / (HairNoV * HairNoV) - 1.0);
                //specular *= multiBounce;

                


                // 合并光照
                float3 radiance = _MainLightColor.rgb * NoL;
                float3 color = (diffuse + specular) * radiance * ao + hairLineColor + HairDownColor;



                
                        



                color += envColor * F;
                color += ambient;
                color += ssr * F;
                // 在最终颜色输出前添加
                color = saturate(color); // 防止过曝


                

                //return float4(color, albedo.a);
                return float4(color, alpha);
            }
            ENDHLSL
        }

        Pass
        {
            Name "DrawOverlay"
            Tags { "LightMode" = "UniversalForward"
                "RenderType" = "Overlay"
                "RenderPipeline" = "UniversalPipeline"
            }
            Cull Off
            Stencil{
                Ref 2
                Comp Equal
            }
            ZWrite On

            Blend SrcAlpha OneMinusSrcAlpha
            BlendOp Add

            HLSLPROGRAM
            #pragma multi_compile _MAIN_LIGHT_SHADOWS
            #pragma multi_compile _MAIN_LIGHT_SHADOWS_CASCADE
            #pragma multi_compile _SHADOWS_SOFT

            #pragma vertex vert
            #pragma fragment frag
            
            #pragma multi_compile_fog

 #if _DRAW_OVERLAY_ON
            // 使用新版核心库
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

// 需要光照输入时添加
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#else

            struct Attributes
            {};
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
            };
            Varyings vert(Attributes input)
            {
                return (Varyings)0;
            }
            float4 frag(Varyings input) : SV_Target
            {
                return 0;
            }
            #endif

            ENDHLSL


        }
         Pass
        {
            Name "DepthOnly"
            Tags { "LightMode" = "DepthOnly" }
            Stencil {
            Ref 0
            Comp Always
            Pass Keep
        }
            ZWrite [_ZWrite]
            ColorMask 0
            Cull [_Cull]

            HLSLPROGRAM

            #pragma multi_compile_instancing
            #pragma multi_compile_DOTS_INSTANCING_ON

            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes
            {
                float4 positionOS : POSITION;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
            };

            //float _AlphaClip;

            Varyings vert(Attributes input)
            {
                Varyings output;
                output.positionCS = TransformObjectToHClip(input.positionOS.xyz);
                return output;
            }

            float4 frag(Varyings input) : SV_TARGET
            {
                clip(1.0 - _AlphaClip);
                return 0;
            }
            ENDHLSL
        }

        Pass
        {
            Name "DepthOnly"
            Tags { "LightMode" = "DepthOnly" }
            ZWrite [_ZWrite]
            ColorMask 0
            Cull [_Cull]

            HLSLPROGRAM

            #pragma multi_compile_instancing
            #pragma multi_compile_DOTS_INSTANCING_ON

            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes
            {
                float4 positionOS : POSITION;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
            };

            //float _AlphaClip;

            Varyings vert(Attributes input)
            {
                Varyings output;
                output.positionCS = TransformObjectToHClip(input.positionOS.xyz);
                return output;
            }

            float4 frag(Varyings input) : SV_TARGET
            {
                clip(1.0 - _AlphaClip);
                return 0;
            }
            ENDHLSL
        }

        Pass
        {
            Name "DepthNormals"
            Tags { "LightMode" = "DepthNormals" }
            Stencil {
            Ref 0
            Comp Always
            Pass Keep
        }
            ZWrite [_ZWrite]
            Cull [_Cull]

            HLSLPROGRAM

            #pragma multi_compile_instancing
            #pragma multi_compile_DOTS_INSTANCING_ON

            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes
            {
                float4 positionOS : POSITION;
                float4 tangentOS : TANGENT;
                float3 normalOS : NORMAL;
                float2 texcoord : TEXCOORD0;
            };

            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 normalWS : TEXCOORD1;
                float4 tangentWS : TEXCOORD2;
            };

            float _AlphaClip;

            Varyings vert(Attributes input)
            {
                Varyings output = (Varyings)0;

                output.uv = input.texcoord;
                output.positionCS = TransformObjectToHClip(input.positionOS.xyz);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);
                VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);

                float3 viewDirWS = GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);                           
                output.normalWS = half3(normalInput.normalWS);
                float sign = input.tangentOS.w * float(GetOddNegativeScale());
                output.tangentWS = half4(normalInput.tangentWS.xyz,sign);

                return output;               
            }

            half4 frag(Varyings input) : SV_Target
            {
                clip(1.0 - _AlphaClip);
                float3 normalWS = input.normalWS.xyz;
                return half4(NormalizeNormalPerPixel(normalWS),0.0);
            }
            ENDHLSL
            
        }

        Pass
            {
                Name "UniversalForward"
                Tags { "LightMode" = "UniversalForward" }
                ZWrite On
                ZTest LEqual
                Cull [_Cull]
                //  Stencil
                //  {
                //      Ref [_StencilRef]
                //      Comp [_StencilComp]
                //      Pass [_StencilPassOp]
                //      Fail [_StencilFailOp]
                //      ZFail [_StencilZFailOp]
                //  }

            HLSLPROGRAM

            #pragma shader_feature_local _SCREEN_SPACE_RIM
            #pragma shader_feature_local _SCREEN_SPACE_SHADOW
            #pragma shader_feature_local _MATCAP_ON

            #pragma vertex MainVS
            #pragma fragment MainPS

            #pragma multi_compile_fog

            ENDHLSL
            }

            Pass
        {
            Name"UniversalForwardOnly"
            Tags
            {
                "LightMode" = "UniversalForwardOnly"
            }
            Cull Front
            ZWrite On

            HLSLPROGRAM
            #pragma shader_feature_local _OUTLINE_PASS

            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_fog
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
             // 定义 select 函数
             float3 select(int id, float3 e0, float3 e1, float3 e2, float3 e3, float3 e4)
             {
                 return id == 0 ? e0 : (id == 1 ? e1 : (id == 2 ? e2 : (id == 3 ? e3 : e4)));
             }
            // If your project has a faster way to get camera fov in shader, you can replace this slow function to your method.
            // For example, you write cmd.SetGlobalFloat("_CurrentCameraFOV",cameraFOV) using a new RendererFeature in C#.
            // For this tutorial shader, we will keep things simple and use this slower but convenient method to get camera fov
            float GetCameraFOV()
            {
                //https://answers.unity.com/questions/770838/how-can-i-extract-the-fov-information-from-the-pro.html
                float t = unity_CameraProjection._m11;
                float Rad2Deg = 180 / 3.1415;
                float fov = atan(1.0f / t) * 2.0 * Rad2Deg;
                return fov;
            }
            float ApplyOutlineDistanceFadeOut(float inputMulFix)
            {
                //make outline "fadeout" if character is too small in camera's view
                return saturate(inputMulFix);
            }
            float GetOutlineCameraFovAndDistanceFixMultiplier(float positionVS_Z)
            {
                float cameraMulFix;
                if(unity_OrthoParams.w == 0)
                {
                    ////////////////////////////////
                    // Perspective camera case
                    ////////////////////////////////

                    // keep outline similar width on screen accoss all camera distance       
                    cameraMulFix = abs(positionVS_Z);

                    // can replace to a tonemap function if a smooth stop is needed
                    cameraMulFix = ApplyOutlineDistanceFadeOut(cameraMulFix);

                    // keep outline similar width on screen accoss all camera fov
                    cameraMulFix *= GetCameraFOV();       
                }
                else
                {
                    ////////////////////////////////
                    // Orthographic camera case
                    ////////////////////////////////
                    float orthoSize = abs(unity_OrthoParams.y);
                    orthoSize = ApplyOutlineDistanceFadeOut(orthoSize);
                    cameraMulFix = orthoSize * 50; // 50 is a magic number to match perspective camera's outline width
                }

                return cameraMulFix * 0.00005; // mul a const to make return result = default normal expand amount WS
            }
            // Push an imaginary vertex towards camera in view space (linear, view space unit), 
            // then only overwrite original positionCS.z using imaginary vertex's result positionCS.z value
            // Will only affect ZTest ZWrite's depth value of vertex shader

            // Useful for:
            // -Hide ugly outline on face/eye
            // -Make eyebrow render on top of hair
            // -Solve ZFighting issue without moving geometry
            float4 NiloGetNewClipPosWithZOffset(float4 originalPositionCS, float viewSpaceZOffsetAmount)
            {
                if(unity_OrthoParams.w == 0)
                {
                    ////////////////////////////////
                    //Perspective camera case
                    ////////////////////////////////
                    float2 ProjM_ZRow_ZW = UNITY_MATRIX_P[2].zw;
                    float modifiedPositionVS_Z = -originalPositionCS.w + -viewSpaceZOffsetAmount; // push imaginary vertex
                    float modifiedPositionCS_Z = modifiedPositionVS_Z * ProjM_ZRow_ZW[0] + ProjM_ZRow_ZW[1];
                    originalPositionCS.z = modifiedPositionCS_Z * originalPositionCS.w / (-modifiedPositionVS_Z); // overwrite positionCS.z
                    return originalPositionCS;    
                }
                else
                {
                    ////////////////////////////////
                    //Orthographic camera case
                    ////////////////////////////////
                    originalPositionCS.z += -viewSpaceZOffsetAmount / _ProjectionParams.z; // push imaginary vertex and overwrite positionCS.z
                    return originalPositionCS;
                }
            }

            struct Attributes
            {
                float4 positionOS   : POSITION;
                float4 tangentOS    : TANGENT;
                float3 normalOS     : NORMAL;
                float2 texcoord     :TEXCOORD0;
                float2 texcoord1    :TEXCOORD1;
                float2 uv: TEXCOORD0;
            };

            struct Varyings
            {
                float4 positionCS  : SV_POSITION;
                float fogFactor    : TEXCOORD1;
                float2 uv: TEXCOORD0;
            };

            //sampler2D _BaseColorTex;;
            float _OutLineWidth;
            float _MaxOutlineZoffset;
            float4 _OutlineColor;
            //float _MaterialIDUSE; // 添加材质ID变量
            //float4 _OutlineColor2;
            //float4 _OutlineColor3;
            //float4 _OutlineColor4;
            //float4 _OutlineColor5;
            //TEXTURE2D(_OtherDataTex);
            //SAMPLER(sampler_OtherDataTex);
            
            //CBUFFER_START(UnityPerMaterial)
            //float4 _Color;
            //float4 _BaseMap_ST;
            //CBUFFER_END

            Varyings vert(Attributes input)
            {   
                //#if !_OUTLINE_PASS
                //return (Varyings)0;
                //#endif

                VertexPositionInputs positionInputs = GetVertexPositionInputs(input.positionOS.xyz);
                VertexNormalInputs normalInputs = GetVertexNormalInputs(input.normalOS,input.tangentOS);

                float width = _OutLineWidth;
                width *= GetOutlineCameraFovAndDistanceFixMultiplier(positionInputs.positionVS.z);

                float3 positionWS = positionInputs.positionWS.xyz;
                positionWS += normalInputs.normalWS * width;

                Varyings output = (Varyings)0;
                output.positionCS = NiloGetNewClipPosWithZOffset(TransformWorldToHClip(positionWS),_MaxOutlineZoffset);
                output.uv = input.texcoord;
                output.fogFactor = ComputeFogFactor(positionInputs.positionCS.z);

                //Varyings OUT;

                //OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                //OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);

                return output;
            }

            float4 frag(Varyings input) : SV_Target
            {
                //float4 texel = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
                float3 outlineColor = 0;

                outlineColor = _OutlineColor.rgb;

                // 使用 _OtherDataTex 的 x 通道选择描边颜色
                // float4 otherData = SAMPLE_TEXTURE2D(_OtherDataTex, sampler_OtherDataTex, input.uv);
                // int materialid = max(0,4 - floor(otherData.x *5)); // 将 x 通道值映射到 0-5的整数范围
                // outlineColor = select(materialid, _OutlineColor.rgb, _OutlineColor2.rgb, _OutlineColor3.rgb, _OutlineColor4.rgb, _OutlineColor5.rgb);
                

                //float3 baseMapColor = SAMPLE_TEXTURE2D(_BaseColorTex, sampler_LinearRepeat, input.uv);
                outlineColor *= 0.1;

                float4 color = float4(outlineColor,1);
                color.rgb = MixFog(color.rgb, input.fogFactor);

                return color;
                //return float4(baseMapColor,1);
            }
            ENDHLSL
        }
         // 阴影投射Pass
        UsePass "Universal Render Pipeline/Lit/ShadowCaster"
    }
    }
